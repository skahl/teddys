/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package edu.teddys.network;

import com.jme3.network.ConnectionListener;
import com.jme3.network.HostedConnection;
import com.jme3.network.Server;
import edu.teddys.BaseGame;
import edu.teddys.network.messages.NetworkMessage;
import edu.teddys.network.messages.NetworkMessageInfo;
import edu.teddys.network.messages.server.ReqMessageSendClientData;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;

/**
 *
 * @author cm
 */
public class TeddyServer implements NetworkCommunicatorAPI, ConnectionListener {

  /**
   * Autogenerated on demand.
   */
  private TeddyServerData data;
  private static TeddyServer instance;

  public static TeddyServer getInstance() {
    if (instance == null) {
      instance = new TeddyServer();
    }
    return instance;
  }

  /**
   * 
   * Start the server. Refresh the server data regarding creation timestamp
   * and discoverability in every case, even when the server is already
   * running.
   * 
   */
  public void startServer() {
    NetworkCommunicatorSpidermonkeyServer.getInstance().startServer(this);
    if(!isRunning()) {
      data = new TeddyServerData();
    }
    getData().setCreated(new Date());
    getData().setDiscoverable(true);
  }

  /**
   * 
   * Check if the server is currently running. That is when getData() returns
   * a non-null value.
   * 
   * @return true if the server is running, else false.
   */
  protected boolean isRunning() {
    if (data != null) {
      return true;
    }
    return false;
  }

  /**
   * This function safely stops the server.
   */
  public void stopServer() {
    if (!isRunning()) {
      return;
    }
    for(int i=0; i<getData().getConnections().size(); i++) {
      getData().getConnections().get(i).close("Going down for maintenance NOW! ;)");
    }
    
    NetworkCommunicatorSpidermonkeyServer.getInstance().shutdownServer();
    // reset data
    data = null;
  }

  public String getPubKey(String pubKeyClient) {
    return NetworkCommunicatorSpidermonkeyServer.getInstance().getPubKey(pubKeyClient);
  }

  public void send(NetworkMessage message) {
    if (!isRunning()) {
      return;
    }
    if (!getData().isDiscoverable()) {
      System.err.println("TeddyServer not discoverable! Message not sent.");
    }
    if (getData().getConnections().isEmpty()) {
      //TODO Save or dismiss the message?
      System.out.println("Message could not be sent because no clients were connected!");
      return;
    }
    NetworkCommunicatorSpidermonkeyServer.getInstance().send(message);
  }

  public boolean join() {
    // dummy value
    return false;
  }

  /**
   * 
   * Call this function instead of disconnect(Integer) if you want to send
   * a reason for disconnecting. This is, for example, if a client gets
   * kicked.
   * 
   * @param client  Client ID
   * @param reason Reason for the disconnect
   */
  public void disconnect(Integer client, String reason) {
    if (!isRunning()) {
      return;
    }
    HostedConnection conn = getData().getConnections().get(client);
    if (conn == null) {
      return;
    }
    conn.close(reason);
  }

  public void disconnect(Integer client) {
    disconnect(client, null);
  }

  protected TeddyServerData getData() {
    return data;
  }

  public void setData(TeddyServerData data) {
    this.data = data;
  }

  public List<Integer> getClientIDs() {
    if(getData() != null && !getData().getClients().isEmpty()) {
      return new ArrayList<Integer>(getData().getClients().keySet());
    }
    return new ArrayList<Integer>();
  }
  
  /**
   * 
   * Return the client data specified by the ID in the current server context.
   * Note: Does not check if the entry exists!
   * 
   * @param id  Client id
   * @return Client data, i. e. the name, health, ...
   */
  public ClientData getClientData(Integer id) {
    return getData().getClients().get(id);
  }

  /**
   * Adds client data to the current list. Existing data will be overwritten!
   */
  public void setClientData(Integer clientID, ClientData client) {
    if (!isRunning()) {
      System.err.println("TeddyServer is not running!");
      return;
    }
    getData().getClients().put(clientID, client);
    BaseGame.getLogger().log(Level.INFO, "setClientData() called from client {0}", clientID);
  }

  /**
   * 
   * Called when a new client has joined the server.
   * 
   * @param server
   * @param conn The client information.
   */
  public void connectionAdded(Server server, HostedConnection conn) {
    if (!isRunning()) {
      System.err.println("connectionAdded() called, but no server data available!");
      return;
    }
    getData().getConnections().add(conn);
    // Check if the ServerDataSync thread should be started.
    checkServerSync();
    
    // Send a status text
    String message = String.format(
            "New connection (%s) arrived! Client ID is %s",
            conn.getAddress(),
            conn.getId());
    NetworkMessageInfo info = new NetworkMessageInfo(message);
    send(info);
    BaseGame.getLogger().info(message);
    
    //TODO send the real name of the server
    // Send some welcome text
    String serverMsg = String.format("Welcome on my server %s!", "Grunute");
    NetworkMessageInfo clientInfo = new NetworkMessageInfo(serverMsg);
    conn.send(clientInfo);
    ReqMessageSendClientData sendMsg = new ReqMessageSendClientData();
    conn.send(sendMsg);
  }

  /**
   * 
   * Called when a client has been disconnected.
   * 
   * @param server
   * @param conn The client information.
   */
  public void connectionRemoved(Server server, HostedConnection conn) {
    
    if (!isRunning()) {
      BaseGame.getLogger().severe("connectionRemoved() called, but no server data available!");
      return;
    }
    
    if(conn == null) {
      // can be true if the server has been shutdown in the meantime.
      return;
    }
    
    if (getData().getConnections().contains(conn)) {

      // Search for the client data of the HostedConnection and remove it 
      // from list

      // acquire client data because of the team allocation
      ClientData client = getData().getClients().get(conn.getId());
      if (client != null) {
        // remove the player from the team list
        if (client.getTeamID() != null) {
          try {
            getData().getTeams().get(client.getTeamID()).removePlayer(client.getId());
          } catch(ArrayIndexOutOfBoundsException ex) {
            //TODO ignore?
            BaseGame.getLogger().log(Level.INFO,
                    "No team with ID {0} could be found!", client.getTeamID());
          }
        }

        // remove the client data from server
        getData().getClients().remove(client.getId());
      }

      String message = String.format(
              "Client %s disconnected.",
              conn.getId());
      getData().getConnections().remove(conn);
      NetworkMessageInfo info = new NetworkMessageInfo(message);
      send(info);
      BaseGame.getLogger().info(message);
      
      // Check if the ServerDataSync thread should be terminated.
      checkServerSync();
      
      return;
    }
    System.err.println(
            String.format("Connection remove request failed from Address %s!",
            conn.getAddress()));
  }

  /**
   * If there is more than one client connected, send the clients a request to
   * synchronize the server data. Otherwise, stop the appropriate thread.
   * 
   * @see ServerDataSync
   */
  private void checkServerSync() {
    if(getData().getConnections().isEmpty() || getData().getConnections().size() < 2) {
      ServerDataSync.stopTimer();
      return;
    }
    ServerDataSync.startTimer();
  }
}
